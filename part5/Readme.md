# Наследование

Наследование в объектно-ориентированном программировании (ООП) — 
это процесс создания новых классов на основе уже существующих.\
В Python наследование позволяет использовать функциональность одного класса в другом классе.\
Класс, который использует функциональность другого класса, называется подклассом (или производным классом), а класс,\
который предоставляет функциональность, называется суперклассом (или базовым классом).


#  Создание базового класса

Создадим базовый класс Person, который будет содержать общую функциональность для всех людей.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def introduce(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")

```

 Мы создали класс Person, который содержит два атрибута: name и age, и метод introduce(), который выводит информацию о человеке.
 
# Создание подкласса

Теперь создадим подкласс Student, который будет наследовать функциональность класса Person и добавлять к ней новую функциональность.

```python
class Student(Person):
    def __init__(self, name, age, school):
        super().__init__(name, age)
        self.school = school

    def study(self):
        print(f"{self.name} учится в {self.school}.")

```

 Создали класс Student, который наследует функциональность класса Person, используя ключевое слово super(). \
 Кроме того, мы добавили новый атрибут school и метод study(), который выводит информацию о том, где учится студент.
 
# Использование наследования

Теперь мы можем использовать наследование, создав объекты класса Person и Student.

```python
person1 = Person("Иван", 25)
person1.introduce() # Привет, меня зовут Иван и мне 25 лет.

student1 = Student("Петр", 18, "Школа №5")
student1.introduce() # Привет, меня зовут Петр и мне 18 лет.
student1.study() # Петр учится в Школа №5

```

# Переопределение методов

При наследовании один класс может переопределить методы суперкласса. \
Для этого нужно определить метод с тем же именем, что и в суперклассе, в подклассе.

```python
class Student(Person):
    def __init__(self, name, age, school):
        super().__init__(name, age)
        self.school = school

    def introduce(self):
        print(f"Привет, меня зовут {self.name}, я учусь в {self.school} и мне {self.age} лет.")

    def study(self):
        print(f"{self.name} учится в {self.school}.")

```

Здесь мы переопределили метод introduce() в классе Student, чтобы выводить дополнительную информацию о том, где учится студент.


# Использование переопределенных методов

Теперь мы можем использовать переопределенный метод introduce().

```python
person1 = Person("Иван", 25)
person1.introduce() # Привет, меня зовут Иван и мне 25 лет.

student1 = Student("Петр", 18, "Школа №5")
student1.introduce() # Привет, меня зовут Петр, я учусь в Школа №5 и мне 18 лет.
student1.study() # Петр учится в Школа №5.

```


# Вызов методов суперкласса

Иногда при переопределении методов необходимо вызвать метод суперкласса. \
Для этого нужно использовать функцию super().

```python
class Student(Person):
    def __init__(self, name, age, school):
        super().__init__(name, age)
        self.school = school

    def introduce(self):
        super().introduce()
        print(f"Я учусь в {self.school}.")

    def study(self):
        print(f"{self.name} учится в {self.school}.")

```


Здесь мы вызываем метод introduce() суперкласса Person с помощью функции super(), а затем выводим информацию о том, где учится студент.


# Множественное наследование

Python позволяет использовать множественное наследование, когда один класс наследует функциональность нескольких классов.

```python
class SchoolMember:
    def __init__(self, name, age, school):
        self.name = name
        self.age = age
        self.school = school

    def introduce(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")

class Student(SchoolMember, Person):
    def __init__(self, name, age, school, grade):
        SchoolMember.__init__(self, name, age, school)
        Person.__init__(self, name, age)
        self.grade = grade

    def study(self):
        print(f"{self.name} учится в {self.school} и его класс {self.grade}.")

    def introduce(self):
        super().introduce()
        print(f"Я учусь в {self.school} и мой класс {self.grade}.")

```

Здесь мы создали класс SchoolMember, который содержит общую функциональность для всех участников школы, а затем создали класс Student, который наследует функциональность обоих классов, SchoolMember и Person.\
Кроме того, мы добавили новый атрибут grade и метод study(), который выводит информацию о классе студента.

# Использование множественного наследования

Теперь мы можем использовать класс Student, создав объекты и вызывая его методы.

```python
person1 = Person("Иван", 25)
person1.introduce() # Привет, меня зовут Иван и мне 25 лет.

school_member1 = SchoolMember("Петр", 18, "Школа №5")
school_member1.introduce() # Привет, меня зовут Петр и мне 18 лет.

student1 = Student("Анна", 16, "Школа №3", 10)
student1.introduce() # Привет, меня зовут Анна и мне 16 лет. Я учусь в Школа №3 и мой класс 10.
student1.study() # Анна учится в Школа №3 и его класс 10.

```




# Пример

```python
"""
Необходимо разработать программу, которая будет реализовывать классы Rectangle и Square,
описывающие прямоугольник (Rectangle) и квадрат (Square), а также демонстрировать наследование классов
и переопределение методов.
Класс Square должен быть унаследован от класса Rectangle,
а также переопределять методы area и perimeter для корректной работы с квадратами.
После необходимо создать объекты Rectangle и Square, вызвать их методы area и perimeter и вывести результат на экран.
"""


# Определяем класс Rectangle
class Rectangle:
    # Определяем метод __init__ (конструктор), который будет вызван при создании нового объекта
    def __init__(self, length, width):
        # Задаем атрибуты объекта: длину и ширину прямоугольника
        self.length = length
        self.width = width

    # Определяем метод area, который будет возвращать площадь прямоугольника
    def area(self):
        return self.length * self.width

    # Определяем метод perimeter, который будет возвращать периметр прямоугольника
    def perimeter(self):
        return 2 * (self.length + self.width)


# Определяем класс Square, который будет наследоваться от класса Rectangle
class Square(Rectangle):
    # Определяем метод __init__, который будет вызываться при создании нового объекта
    # Классу Square передается только один параметр, так как все стороны квадрата равны
    def __init__(self, side):
        # Вызываем конструктор родительского класса и передаем ему значение стороны квадрата для обоих атрибутов
        super().__init__(side, side)

    # Переопределяем метод area для класса Square, чтобы он возвращал площадь квадрата
    def area(self):
        return self.length ** 2

    # Переопределяем метод perimeter для класса Square, чтобы он возвращал периметр квадрата
    def perimeter(self):
        return 4 * self.length


# Создаем объекты классов Rectangle и Square
rectangle1 = Rectangle(10, 20)
rectangle2 = Square(10)

# Выводим на экран площадь и периметр каждого прямоугольника
print(rectangle1.area())
print(rectangle1.perimeter())
print(rectangle2.area())
print(rectangle2.perimeter())

```
_______________________________
_______________________________
_______________________________

# Задачи для самостоятельного решения

## Задача 1

Создайте класс Animal, который будет содержать общую функциональность для всех животных, и классы Cat и Dog, которые будут наследовать функциональность класса Animal и добавлять к ней новую функциональность. \
Класс Cat должен содержать метод meow(), который будет выводить на экран "Мяу!", а класс Dog должен содержать метод bark(), который будет выводить на экран "Гав!".

## Задача 2

Создайте класс Rectangle, который будет содержать метод area(), вычисляющий площадь прямоугольника, и метод perimeter(), вычисляющий периметр прямоугольника. \
Затем создайте подкласс Square, который будет наследовать функциональность класса Rectangle и переопределить метод area(), чтобы он вычислял площадь квадрата. \
Кроме того, метод perimeter() должен оставаться без изменений.

## Задача 3

Создайте класс Employee, который будет содержать атрибуты name и salary, и метод get_bonus(), который будет вычислять размер бонуса для сотрудника. \
Затем создайте подкласс Manager, который будет наследовать функциональность класса Employee и добавлять к ней новую функциональность. \
Класс Manager должен содержать метод get_bonus(), который будет вычислять размер бонуса для менеджера, основываясь на зарплате и проценте бонуса. \
Метод get_bonus() должен вызывать метод суперкласса, чтобы вычислить базовый размер бонуса для сотрудника.

## Задача 4

Создайте класс Account, который будет содержать методы для работы с банковским счетом, такие как deposit() и withdraw(). \
Затем создайте класс CreditCard, который будет наследовать функциональность класса Account и добавлять к ней новую функциональность, такую как charge_interest(), который будет вычислять проценты по кредитной карте. \
Далее создайте класс SavingsAccount, который также будет наследовать функциональность класса Account и добавлять к ней новую функциональность, такую как add_interest(), который будет вычислять проценты по сберегательному счету.

